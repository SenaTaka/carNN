<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>carNN Track Editor - „Ç≥„Éº„Çπ„Ç®„Éá„Ç£„Çø</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }
        
        .content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 0;
        }
        
        .sidebar {
            background: #f8f9fa;
            padding: 25px;
            border-right: 1px solid #e0e0e0;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .sidebar h2 {
            font-size: 1.4em;
            margin-bottom: 20px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        .control-group input[type="number"],
        .control-group input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .canvas-container {
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #fafafa;
        }
        
        #trackCanvas {
            border: 3px solid #667eea;
            border-radius: 8px;
            cursor: crosshair;
            background: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }
        
        .info-box p {
            margin: 5px 0;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .stats {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }
        
        .stats h3 {
            margin-bottom: 10px;
            color: #856404;
        }
        
        .stats p {
            margin: 5px 0;
            font-size: 13px;
            color: #856404;
        }
        
        .mode-indicator {
            background: #28a745;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: 600;
            font-size: 12px;
        }
        
        .mode-indicator.move {
            background: #ffc107;
            color: #333;
        }
        
        .waypoint-list {
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
        }
        
        .waypoint-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .waypoint-item:hover {
            background: #e9ecef;
        }
        
        .waypoint-item.selected {
            background: #667eea;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèéÔ∏è carNN Track Editor</h1>
            <p>„Éì„Ç∏„É•„Ç¢„É´„Å´„É¨„Éº„Ç∑„É≥„Ç∞„Ç≥„Éº„Çπ„Çí‰ΩúÊàê„Åó„Çà„ÅÜÔºÅ</p>
        </div>
        
        <div class="content">
            <div class="sidebar">
                <h2>‚öôÔ∏è „Ç≥„É≥„Éà„É≠„Éº„É´</h2>
                
                <div class="mode-indicator" id="modeIndicator">
                    „É¢„Éº„Éâ: „Ç¶„Çß„Ç§„Éù„Ç§„É≥„ÉàËøΩÂä†
                </div>
                
                <div class="info-box">
                    <p><strong>‰Ωø„ÅÑÊñπ:</strong></p>
                    <p>‚Ä¢ „ÇØ„É™„ÉÉ„ÇØ„Åß„Ç¶„Çß„Ç§„Éù„Ç§„É≥„Éà„ÇíËøΩÂä†</p>
                    <p>‚Ä¢ „Ç¶„Çß„Ç§„Éù„Ç§„É≥„Éà„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÁßªÂãï</p>
                    <p>‚Ä¢ „Ç¶„Çß„Ç§„Éù„Ç§„É≥„Éà„ÇíÂè≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§</p>
                    <p>‚Ä¢ „Éû„Ç¶„Çπ„Éõ„Ç§„Éº„É´„Åß„Ç∫„Éº„É†</p>
                </div>
                
                <div class="control-group">
                    <button class="btn-secondary" id="toggleModeBtn">
                        üñ±Ô∏è ÁßªÂãï„É¢„Éº„Éâ„Å´ÂàáÊõø
                    </button>
                </div>
                
                <div class="control-group">
                    <label for="trackWidth">„Ç≥„Éº„ÇπÂπÖ (m)</label>
                    <input type="number" id="trackWidth" value="7.5" min="3" max="20" step="0.5">
                </div>
                
                <div class="control-group">
                    <label for="scale">„Çπ„Ç±„Éº„É´</label>
                    <input type="number" id="scale" value="2.0" min="0.5" max="5" step="0.1">
                </div>
                
                <div class="control-group">
                    <label for="splinePoints">„Çπ„Éó„É©„Ç§„É≥Ëß£ÂÉèÂ∫¶</label>
                    <input type="number" id="splinePoints" value="50" min="10" max="100" step="10">
                </div>
                
                <h2>üìù „Ç¶„Çß„Ç§„Éù„Ç§„É≥„Éà</h2>
                <div class="waypoint-list" id="waypointList"></div>
                
                <div class="control-group">
                    <button class="btn-danger" id="clearBtn">
                        üóëÔ∏è „Åô„Åπ„Å¶ÂâäÈô§
                    </button>
                </div>
                
                <h2>üíæ „Ç®„ÇØ„Çπ„Éù„Éº„Éà</h2>
                
                <div class="control-group">
                    <button class="btn-success" id="exportJsonBtn">
                        üì• JSON„Åß„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
                    </button>
                </div>
                
                <div class="control-group">
                    <button class="btn-primary" id="exportPythonBtn">
                        üêç Python„Ç≥„Éº„Éâ„Çí„Ç≥„Éî„Éº
                    </button>
                </div>
                
                <div class="control-group">
                    <label for="loadJson">JSON„Çí„É≠„Éº„Éâ</label>
                    <input type="file" id="loadJson" accept=".json" style="display:none">
                    <button class="btn-secondary" onclick="document.getElementById('loadJson').click()">
                        üìÇ „Éï„Ç°„Ç§„É´„ÇíÈñã„Åè
                    </button>
                </div>
                
                <div class="stats">
                    <h3>üìä Áµ±Ë®à</h3>
                    <p id="waypointCount">„Ç¶„Çß„Ç§„Éù„Ç§„É≥„ÉàÊï∞: 0</p>
                    <p id="trackLength">„Ç≥„Éº„ÇπÈï∑: 0 m</p>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="trackCanvas" width="1000" height="800"></canvas>
            </div>
        </div>
    </div>
    
    <script>
        // Canvas setup
        const canvas = document.getElementById('trackCanvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let waypoints = [];
        let mode = 'add'; // 'add' or 'move'
        let selectedWaypoint = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let panOffset = { x: canvas.width / 2, y: canvas.height / 2 };
        let zoom = 1.0;
        
        // Default waypoints (same as in g_save.py)
        const defaultWaypoints = [
            [0, -20], [-30, -20], [-20, 20], [-10, 30], [10, 40],
            [80, 80], [100, 70], [90, 50], [110, 30], [90, -10],
            [100, -50], [60, -70], [20, -60], [0, -40]
        ];
        
        // Initialize with default waypoints
        waypoints = defaultWaypoints.map(p => ({ x: p[0], y: p[1] }));
        
        // Catmull-Rom spline interpolation
        function catmullRomSpline(P0, P1, P2, P3, nPoints) {
            const points = [];
            for (let i = 0; i < nPoints; i++) {
                const t = i / (nPoints - 1);
                const t2 = t * t;
                const t3 = t2 * t;
                
                const c0 = -0.5 * t3 + t2 - 0.5 * t;
                const c1 = 1.5 * t3 - 2.5 * t2 + 1.0;
                const c2 = -1.5 * t3 + 2.0 * t2 + 0.5 * t;
                const c3 = 0.5 * t3 - 0.5 * t2;
                
                const x = c0 * P0.x + c1 * P1.x + c2 * P2.x + c3 * P3.x;
                const y = c0 * P0.y + c1 * P1.y + c2 * P2.y + c3 * P3.y;
                
                points.push({ x, y });
            }
            return points;
        }
        
        // Generate track from waypoints
        function generateTrack() {
            if (waypoints.length < 3) return [];
            
            const scale = parseFloat(document.getElementById('scale').value);
            const splinePoints = parseInt(document.getElementById('splinePoints').value);
            const scaledWaypoints = waypoints.map(p => ({ x: p.x * scale, y: p.y * scale }));
            
            const track = [];
            const n = scaledWaypoints.length;
            
            for (let i = 0; i < n; i++) {
                const P0 = scaledWaypoints[(i - 1 + n) % n];
                const P1 = scaledWaypoints[i];
                const P2 = scaledWaypoints[(i + 1) % n];
                const P3 = scaledWaypoints[(i + 2) % n];
                
                const segment = catmullRomSpline(P0, P1, P2, P3, splinePoints);
                track.push(...segment);
            }
            
            return track;
        }
        
        // Calculate track normals
        function calculateNormals(track, halfWidth) {
            if (track.length < 2) return { inner: [], outer: [] };
            
            const normals = [];
            for (let i = 0; i < track.length; i++) {
                const prev = track[(i - 1 + track.length) % track.length];
                const next = track[(i + 1) % track.length];
                
                const dx = next.x - prev.x;
                const dy = next.y - prev.y;
                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                
                normals.push({ x: -dy / len, y: dx / len });
            }
            
            const inner = track.map((p, i) => ({
                x: p.x + normals[i].x * halfWidth,
                y: p.y + normals[i].y * halfWidth
            }));
            
            const outer = track.map((p, i) => ({
                x: p.x - normals[i].x * halfWidth,
                y: p.y - normals[i].y * halfWidth
            }));
            
            return { inner, outer };
        }
        
        // World to screen coordinates
        function worldToScreen(wx, wy) {
            return {
                x: wx * zoom + panOffset.x,
                y: -wy * zoom + panOffset.y  // Flip Y axis
            };
        }
        
        // Screen to world coordinates
        function screenToWorld(sx, sy) {
            return {
                x: (sx - panOffset.x) / zoom,
                y: -(sy - panOffset.y) / zoom  // Flip Y axis
            };
        }
        
        // Draw the track
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            const gridSize = 50 * zoom;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw origin
            const origin = worldToScreen(0, 0);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(origin.x - 10, origin.y);
            ctx.lineTo(origin.x + 10, origin.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y - 10);
            ctx.lineTo(origin.x, origin.y + 10);
            ctx.stroke();
            
            // Draw track
            if (waypoints.length >= 3) {
                const track = generateTrack();
                const trackWidth = parseFloat(document.getElementById('trackWidth').value);
                const { inner, outer } = calculateNormals(track, trackWidth);
                
                // Draw road
                ctx.fillStyle = '#444444';
                ctx.beginPath();
                outer.forEach((p, i) => {
                    const screen = worldToScreen(p.x, p.y);
                    if (i === 0) ctx.moveTo(screen.x, screen.y);
                    else ctx.lineTo(screen.x, screen.y);
                });
                for (let i = inner.length - 1; i >= 0; i--) {
                    const screen = worldToScreen(inner[i].x, inner[i].y);
                    ctx.lineTo(screen.x, screen.y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw borders
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                inner.forEach((p, i) => {
                    const screen = worldToScreen(p.x, p.y);
                    if (i === 0) ctx.moveTo(screen.x, screen.y);
                    else ctx.lineTo(screen.x, screen.y);
                });
                ctx.closePath();
                ctx.stroke();
                
                ctx.beginPath();
                outer.forEach((p, i) => {
                    const screen = worldToScreen(p.x, p.y);
                    if (i === 0) ctx.moveTo(screen.x, screen.y);
                    else ctx.lineTo(screen.x, screen.y);
                });
                ctx.closePath();
                ctx.stroke();
                
                // Draw goal line
                if (inner.length > 0 && outer.length > 0) {
                    ctx.strokeStyle = '#ff0055';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const innerStart = worldToScreen(inner[0].x, inner[0].y);
                    const outerStart = worldToScreen(outer[0].x, outer[0].y);
                    ctx.moveTo(innerStart.x, innerStart.y);
                    ctx.lineTo(outerStart.x, outerStart.y);
                    ctx.stroke();
                }
                
                // Update stats
                const trackLength = track.reduce((sum, p, i) => {
                    if (i === 0) return 0;
                    const prev = track[i - 1];
                    const dx = p.x - prev.x;
                    const dy = p.y - prev.y;
                    return sum + Math.sqrt(dx * dx + dy * dy);
                }, 0);
                document.getElementById('trackLength').textContent = `„Ç≥„Éº„ÇπÈï∑: ${trackLength.toFixed(1)} m`;
            }
            
            // Draw waypoint connections
            if (waypoints.length > 1) {
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                waypoints.forEach((p, i) => {
                    const screen = worldToScreen(p.x, p.y);
                    if (i === 0) ctx.moveTo(screen.x, screen.y);
                    else ctx.lineTo(screen.x, screen.y);
                });
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw waypoints
            waypoints.forEach((p, i) => {
                const screen = worldToScreen(p.x, p.y);
                const isSelected = selectedWaypoint === i;
                
                ctx.fillStyle = isSelected ? '#ff6b6b' : '#667eea';
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, isSelected ? 10 : 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Draw waypoint number
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i.toString(), screen.x, screen.y);
            });
            
            // Update waypoint count
            document.getElementById('waypointCount').textContent = `„Ç¶„Çß„Ç§„Éù„Ç§„É≥„ÉàÊï∞: ${waypoints.length}`;
        }
        
        // Update waypoint list
        function updateWaypointList() {
            const list = document.getElementById('waypointList');
            list.innerHTML = '';
            
            waypoints.forEach((p, i) => {
                const item = document.createElement('div');
                item.className = 'waypoint-item' + (selectedWaypoint === i ? ' selected' : '');
                item.innerHTML = `
                    <span>#${i}: (${p.x.toFixed(1)}, ${p.y.toFixed(1)})</span>
                `;
                item.onclick = () => {
                    selectedWaypoint = i;
                    updateWaypointList();
                    draw();
                };
                list.appendChild(item);
            });
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;
            const world = screenToWorld(sx, sy);
            
            if (e.button === 0) { // Left click
                if (mode === 'add') {
                    waypoints.push({ x: Math.round(world.x), y: Math.round(world.y) });
                    selectedWaypoint = waypoints.length - 1;
                    updateWaypointList();
                    draw();
                } else if (mode === 'move') {
                    // Check if clicking on a waypoint
                    for (let i = 0; i < waypoints.length; i++) {
                        const screen = worldToScreen(waypoints[i].x, waypoints[i].y);
                        const dx = screen.x - sx;
                        const dy = screen.y - sy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 15) {
                            isDragging = true;
                            selectedWaypoint = i;
                            dragOffset = { x: world.x - waypoints[i].x, y: world.y - waypoints[i].y };
                            updateWaypointList();
                            draw();
                            break;
                        }
                    }
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && selectedWaypoint !== null) {
                const rect = canvas.getBoundingClientRect();
                const sx = e.clientX - rect.left;
                const sy = e.clientY - rect.top;
                const world = screenToWorld(sx, sy);
                
                waypoints[selectedWaypoint].x = Math.round(world.x - dragOffset.x);
                waypoints[selectedWaypoint].y = Math.round(world.y - dragOffset.y);
                updateWaypointList();
                draw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;
            
            // Check if clicking on a waypoint to delete
            for (let i = 0; i < waypoints.length; i++) {
                const screen = worldToScreen(waypoints[i].x, waypoints[i].y);
                const dx = screen.x - sx;
                const dy = screen.y - sy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 15) {
                    waypoints.splice(i, 1);
                    selectedWaypoint = null;
                    updateWaypointList();
                    draw();
                    break;
                }
            }
        });
        
        // Zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom *= delta;
            zoom = Math.max(0.1, Math.min(5, zoom));
            draw();
        });
        
        // Button events
        document.getElementById('toggleModeBtn').addEventListener('click', () => {
            mode = mode === 'add' ? 'move' : 'add';
            const indicator = document.getElementById('modeIndicator');
            const btn = document.getElementById('toggleModeBtn');
            
            if (mode === 'add') {
                indicator.textContent = '„É¢„Éº„Éâ: „Ç¶„Çß„Ç§„Éù„Ç§„É≥„ÉàËøΩÂä†';
                indicator.className = 'mode-indicator';
                btn.textContent = 'üñ±Ô∏è ÁßªÂãï„É¢„Éº„Éâ„Å´ÂàáÊõø';
            } else {
                indicator.textContent = '„É¢„Éº„Éâ: „Ç¶„Çß„Ç§„Éù„Ç§„É≥„ÉàÁßªÂãï';
                indicator.className = 'mode-indicator move';
                btn.textContent = '‚ûï ËøΩÂä†„É¢„Éº„Éâ„Å´ÂàáÊõø';
            }
        });
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('„Åô„Åπ„Å¶„ÅÆ„Ç¶„Çß„Ç§„Éù„Ç§„É≥„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                waypoints = [];
                selectedWaypoint = null;
                updateWaypointList();
                draw();
            }
        });
        
        document.getElementById('trackWidth').addEventListener('input', draw);
        document.getElementById('scale').addEventListener('input', draw);
        document.getElementById('splinePoints').addEventListener('input', draw);
        
        // Export functions
        document.getElementById('exportJsonBtn').addEventListener('click', () => {
            const data = {
                waypoints: waypoints.map(p => [p.x, p.y]),
                trackWidth: parseFloat(document.getElementById('trackWidth').value),
                scale: parseFloat(document.getElementById('scale').value)
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'track.json';
            a.click();
            URL.revokeObjectURL(url);
        });
        
        document.getElementById('exportPythonBtn').addEventListener('click', () => {
            const code = `# Generated track waypoints
base_waypoints = np.array([
${waypoints.map(p => `    [${p.x}, ${p.y}]`).join(',\n')}
])
scale = ${document.getElementById('scale').value}
track_width = ${document.getElementById('trackWidth').value}
`;
            
            navigator.clipboard.writeText(code).then(() => {
                alert('Python„Ç≥„Éº„Éâ„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ\ng_save.py „ÅÆ generate_complex_track() Èñ¢Êï∞„Å´Ë≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            });
        });
        
        // Load JSON
        document.getElementById('loadJson').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        waypoints = data.waypoints.map(p => ({ x: p[0], y: p[1] }));
                        document.getElementById('trackWidth').value = data.trackWidth || 7.5;
                        document.getElementById('scale').value = data.scale || 2.0;
                        selectedWaypoint = null;
                        updateWaypointList();
                        draw();
                    } catch (err) {
                        alert('JSON„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });
        
        // Initial draw
        updateWaypointList();
        draw();
    </script>
</body>
</html>
